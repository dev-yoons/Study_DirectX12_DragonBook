# Chapter4_2. Direct3D의 초기화 - CPU와 GPU의 상호작용

### CPU-GPU 상호작용
--------------------------------------------------
* 그래픽 프로그래밍에서는 CPU와 GPU, 두 가지 처리 장치가 작동한다.
* 이들은 병렬로 작동하지만 종종 동기화가 필요하다. 동기화는 한 처리 장치가 작업을 마칠 때까지 다른 한 처리 장치가 놀아야 함을 의미하며, 성능에 바람직하지 않다.

* #### 명령 대기열과 명령 목록
  * GPU에는 명령 대기열이 하나 있다. 
  * CPU는 그리기 명령들이 담긴 명령 목록을 Direct3D API를 통해서 그 대기열에 제출한다.
  * 명령은 GPU가 처리할 준비가 되어야 비로소 실행된다. 즉 GPU가 이전에 제출된 명령들을 처리할 때, 명령들은 대기열에 남아있다.
  * 따라서 명령 대기열이 비면 GPU는 놀고, 반대로 대기열이 꽉 차면 대기열에 자리가 생길 때까지 CPU가 놀게 된다.  
  ####
  * Direct3D 12에서 명령 대기열을 대표하는 인터페이스는 ID3D12CommandQueue 이다.
  * 이 인터페이스를 생성하려면 대기열을 서술하는 D3D12_COMMAND_QUEUE_DESC 구조체를 채운 후 ID3D12Device::CreateCommandQueue 를 호출해야 한다.
  * 이 인터페이스의 주요 메서드 중 하나로 명령 목록에 있는 명령들을 대기열에 추가하는 ExecuteCommandLists 메서드가 있다.
  ```C++
  void ID3D12CommandQueue::ExecuteCommandLists(
      UINT Count, // 배열의 명령 목록 개수
      ID3D12CommandList *const *ppCommandLists // 배열의 첫 원소를 가리키는 포인터 );
  )
  ```
  * 이 메서드의 선언에서 보듯, 명령 목록을 대표하는 인터페이스는 ID3D12CommandList이지만, 실제 그래픽 작업을 위한 명령 목록은 이 인터페이스를 상속하는 ID3D12GraphicsCommandList 라는 인터페이스로 대표된다.
  * 아래 코드는 뷰포트를 설정하고, 렌더 대상 뷰를 지우고, 그리기 호출을 실행하는 명령들을 추가한다.
  ```C++
  // mCommandList는 ID3D12CommandList 포인터
  mCommandList->RSSetViewports(1, &mScreenViewport);
  mCommandList->ClearRenderTargetView(mBackBufferView, Colors::LightSteelBlue, 0,nullptr);
  mCommandList->DrawIndexedInstanced(36,1,0,0,0);
  ```
  * 위 코드는 그냥 명령들을 명령 목록에 추가할 뿐, ExecuteCommandLists를 호출해야 비로소 명령들이 명령 대기열에 추가된다.
  * 명령들을 명령 목록에 다 추가했으면, ExecuteCommandLists로 명령 목록을 제출하기 전에 반드시 Close 메서드를 호출하여 명령들의 기록이 끝났음을 Direct3D에게 알려주어야 한다.
  ```C++
  mCommandList->Close();
  ```
  ####
  * 명령 목록에는 ID3D12CommandAllocator 형식의 메모리 할당자가 하나 연관된다. 명령 목록에 추가된 명령들은 이 할당자의 메모리에 저장된다. 
  * ExecuteCommandLists로 명령 목록을 제출하면, 명령 대기열은 그 할당자에 담긴 명령들을 참고한다.
  * 명령 메모리 할당자와 명령 목록은 ID3D12Device의 메서드를 사용해서 생성한다.
  ####
  * 하나의 할당자를 여러 명령 목록에 연관시킬 수 있으나, 명령들을 여러 명령 목록에 동시에 기록하는 것은 불가능하다.
  * 명령 목록을 생성하거나 재생성하면 명령 목록은 '열린' 상태가 된다. 현재 명령을 추가하는 명령 목록을 제외한 다른 모든 명령 목록은 '닫혀' 있어야 한다.
  ####
  * Reset 메소드로 명령 목록을 재설정할 수 있다. 이를 통해 명령 목록을 해제하고 새로 명령 목록을 할당하지 않고도 명령 목록의 내부 메모리를 재사용할 수 있다. 하지만, 명령 대기열이 참조하는 명령들은 명령 할당자의 메모리에 남아 있기 때문에 명령 대기열에 있는 명령들에게는 영향이 없다.
  ####
  *  렌더링 명령들을 모두 GPU에 제출한 후에는 명령 할당자의 메모리를 다음 프레임을 위해 재사용해야 한다. 이 때, ID3D12CommandALlocator::Reset 메소드를 사용한다. 
  *  명령 대기열이 할당자 안의 자료를 참조하고 있을 수 있으므로, GPU가 명령 할당자에 담긴 모든 명령을 실행했음이 확실해지기 전까지는 명령 할당자를 재설정하지 말아야 한다.

* #### CPU/GPU 동기화
  * 만약 GPU가 그리기 명령을 실행하기 전에, CPU가 그리기 명령이 참조하는 자원을 덮어쓴다면 의도한 그리기 명령이 실행되지 않을 것이다.
  * 이런 문제의 해결법은 GPU가 명령 대기열의 명령들 중 특정 지점까지의 모든 명령을 다 처리할 때까지 CPU를 기다리게 하는 것이다. 
  * 대기열의 모든 명령을 처리하는 것을 가리켜 명령 대기열을 비운다, 방출한다, 또는 **flush**한다 라고 말한다. 
  * 이 때 필요한 것이 울타리(fence) 라고 부르는 객체이다.

  ####

  * 울타리는 ID3D12Fence 인터페이스로 대표되며, 울타리 객체는 UINT64 값 하나를 관리한다. 이 값은 시간상의 특정 울타리 지점을 식별하는 정수이다.
  
* #### 자원 상태 전이
  * GPU가 자원에 자료를 다 기록하지 않았거나, 기록을 시작하지 않은 상태에서 자료를 읽으려할 때, 이를 **자원 위험 상황**이라고 부른다.
  * 이 문제를 해결하기 위해 Direct3D는 자원들에 상태를 부여한다. 새로 생성된 자원은 기본 상태로 시작하고, 응용 프로그램은 상태 전이를 Direct3D에게 보고한다. 
  * 예를 들어 텍스처 자원에 자료를 기록해야할 때에, 그 텍스처의 상태를 렌더 대상 상태로 설정한다. 이후 텍스처의 자료를 읽어야할 때가 되면 상태를 셰이더 자원 상태로 변경한다.
  ####
  * 자원 상태 전이는 전이 자원 장벽들의 배열을 설정해서 지정한다.
  * 배열을 사용하기 때문에 한 번의 API 호출로 여러 개의 자원을 전이할 수 있다.
  * D3D12_RESOURCE_BARRIER_DESC 구조체로 서술된다.
  * 전이 지원 장벽은 GPU에게 자원의 상태가 전이됨을 알려주는 하나의 명령이라고 생각해도 된다.

* #### 명령 목록을 이용한 다중 스레드 활용
  * Direct3D 12는 멀티쓰레드를 효율적으로 활용할 수 있도록 설계되어있다.
  * 물체가 많은 큰 장면을 다룰 때, 장면을 여러 개의 명령 목록을 병렬로 구축하는 데 멀티쓰레딩을 활용 가능하다.