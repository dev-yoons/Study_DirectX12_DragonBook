# Chapter4_1. Direct3D의 초기화 - 기본 지식

## 요약
--------------------------------------------------
* Direct3D 개요
* COM
* 텍스처 형식
* 교환 사슬과 페이지 전환
* 깊이 버퍼링
* 자원과 서술자
* 다중표본화의 이론
* Direct3D의 다중표본화
* DXGI
* 상주성

### 기본 지식
--------------------------------------------------
* #### Direct3D 개요

    * Direct3D는 응용 프로그램에서 GPU를 제어하고 프로그래밍하는 데 쓰이는 저수준 그래픽 API 이다.     
    ####
    * 하드웨어 드라이브가 Direct3D명령들을 GPU가 이해하는 기계어 명령으로 번역해주므로, GPU가 Direct3D를 지원하는 한, GPU의 세부사항을 걱정하지 않아도 된다.

* #### COM
    * Component Object Model의 줄임말이다.
    ####
    * DirectX의 프로그래밍 언어 독립성과 하위 호환성을 가능하게 하는 기술이다.
    ####
    * COM 객체는 수명 관리를 위해 WRL (Windows Runtime Library) 은 Microsoft::WRL::ComPtr 클래스를 제공한다.
    * 이 클래스는 COM 객체를 위한 Smart Pointer 이며, 범위를 벗어난 ComPtr 인스턴스는 COM 객체에 대해 자동으로 Release를 호출한다. 따라서 프로그래머가 직접 Release를 호출할 필요가 없다.
    ####
    * 이 책에서는 아래 세 가지만 사용한다.
      * Get 
        * 바탕 COM 인터페이스를 가리키는 포인터를 돌려준다.
      * GetAddressOf 
        * 바탕 COM 인터페이스를 가리키는 포인터의 주소를 돌려준다.
      * Reset
        * ComPtr 인스턴스를 nullptr로 설정, 바탕 COM 인터페이스의 참조 횟수를 1 감소한다.
    
* #### 텍스처 형식
    * 2차원 텍스처는 원소들의 행렬 (2차원 배열) 이다.
    * 2차원 텍스처의 용도 하나는 2차원 이미지 자료를 저장하는 것인데, 이 때 각 원소는 픽셀 하나의 색상이 된다.
    * 텍스처에는 특정 형식의 자료 원소들만 담을 수 있다. 
    * 구체적인 형식은 DXGI_FORMAT 이라는 열거형으로 지정한다.
        * Ex) DXGI_FORMAT_R32G32B32_FLOAT
         
* #### 교환 사슬과 페이지 전환
  
    1. 애니메이션의 한 프레임 전체를 화면 바깥의 텍스처에 그린다. 
    (그 텍스처를 후면 버퍼라고 부른다.)
    2. 후면 버퍼를 하나의 완전한 프레임으로서 화면에 표시한다.
    ####
    * 위의 방법을 사용하면 프레임이 그려지는 과정이 나타나지 않아 애니메이션이 껌벅이는 현상을 피할 수 있다. 
    * 이러한 기법을 이중 버퍼링이라고 부른다.
    ####
    * 이중 버퍼링을 효율적으로 구현하려면 하드웨어로 관리되는 전면 버퍼, 후면 버퍼, 두 개의 텍스처 버퍼가 필요하다. 
    ####
    * 화면에는 전면 버퍼에 담긴 표시 되며, 전면 버퍼가 화면에 표시될 동안 애니메이션의 다음 프레임을 후면 버퍼에 그린다. 다 그려지면 전면 버퍼와 후면 버퍼의 역할을 맞바꾼다. 
    * 이와 같은 페이지 전환을 Direct3D에서는 **제시 (presenting)** 이라고 부른다.
    ####
    * 전면 버퍼와 후면 버퍼는 **교환 사슬 (Swap Chain)** 을 형성한다.
    ####
    * Direct3D에서 교환 사슬을 대표하는 인터페이스는 IDXGISwapChain이다. 이 인터페이스는 전면 버퍼 텍스처와 후면 버퍼 텍스처를 담고, 버퍼 크기 변경을 위한 메서드와 버퍼의 제시를 위한 메서드도 제공한다.

* #### 깊이 버퍼링
    * 깊이 버퍼는 이미지 자료를 담지 않는 텍스처 중 하나이다.
    * 깊이 버퍼는 각 픽셀의 깊이 정보를 담는다. 픽셀의 깊이는 0.0 ~ 1.0 사이의 값으로, 0.0은 관찰자에 최대한 가까운 물체, 1.0 은 관찰자와 최대한 먼 물체에 해당한다.
    * 깊이 버퍼의 원소들은 후면 버퍼의 픽셀들과 일대일로 대응된다. 
    즉, 1280x1024 해상도의 후면 버퍼가 있다면, 깊이 버퍼 또한 1280 x 1024 개의 원소들로 구성된다.
    * Direct3D는 한 물체의 픽셀들이 다른 물체보다 앞에 있는지 판정하기 위해, 
    깊이 버퍼링, 또는 z-버퍼링 이라는 기법을 사용한다.
    ####
    * 깊이 버퍼링은 픽셀의 깊이 값이 깊이 버퍼에 이미 들어 있떤 값보다 작은 경우에만 후면 버퍼와 깊이 버퍼에 기록되도록 작동한다. 항상 관찰자에 가장 가까운 픽셀만이 렌더링된다.
    ####
    * 깊이 버퍼 역시 하나의 텍스처이므로 생성 시 특정한 자료 원소 형식을 지정할 필요가 있다. 다음과 같은 것이 사용된다.
      * DXGI_FORMAT_D32_FLOAT_S8X24_UINT
        * 각 텍셀은 32비트 부동소수점 깊이 값과 [0,255] 구간으로 사상되는 부호 없는 8비트 정수 스텐실 값 (스텐실 버퍼에 쓰임), 그리고 다른 용도 없이 채움 용으로만 쓰이는 24비트로 구성된다.

* #### 자원과 서술자
  * 렌더링 과정에서, 그리기 명령을 제출하기 전에 해당 그리기 호출이 참조할 자원들을 렌더링 파이프라인에 **묶어야 (bind)** 한다. 이를 자원을 파이프라인에 **연결한다(link)** 또는 **바인딩한다** 라고 말하기도 한다.
  ####
  * GPU 자원들이 파이프라인에 직접 묶이는 것은 아니다. 실제로 묶이는 것은 해당 자원을 참조하는 **서술자** 객체이다.
  ####
  * 서술자 객체는 자원을 GPU에게 서술해주는 경량의 자료구조라고 할 수 있다. 이는 하나의 간접층이다. GPU는 자원 서술자를 통해 자원의 실제 자료에 접근하고, 그 자료를 사용하는 데 필요한 정보 역시 서술자로부터 얻는다. 그리기 호출이 참조할 서술자들을 명시할 때, 해당 자원들이 렌더링 파이프라인에 묶인다.
  ####
  * GPU 자원은 사실상 범용적인 메모리 조각이기 때문에 서술자들을 거치는 추가적인 간접층이 필요하다. 자원은 범용적으로 사용가능하지만 자체적으로 자신이 렌더 대상인지 셰이더 자원인지 알 수 없고, 일부 영역만 렌더링 파이프라인에 묶고 싶어도 그런 부분 영역에 대한 정보도 없으며, 무형식적으로 생성될 수도 있다. 그런 경우 GPU는 자원의 형식을 알 수 없다. 이런 문제를 해결하기 위해 서술자가 존재하며, 서술자는 자원 자료를 지정하는 수단이자 자원을 GPU에 서술하는 수단이다. 
  ####
  * 서술자는 Direct3D 에게 자원을 파이프라인의 어떤 단계에 묶어야하는지 알려주거나, 파이프라인에 묶을 자원의 부분 영역을 지정하거나, 무형식으로 생성된 자원의 구체적인 형식을 명시할 수 있다.
  * 뷰는 서술자와 동의어이다.
  ####
  * 서술자는 자원의 사용법에 따라 여러 종류가 있다.
    * CBV/SRV/UAV 서술자들은 각각 상수 버퍼, 셰이더 자원, 순서 없는 접근을 서술한다.
    (Constant Buffer, Shader Resource, Unordered Access)
    * 표본추출기 서술자는 텍스처 적용에 쓰이는 표본추출기 자원을 서술한다.
    * RTV 서술자는 렌더 대상 자원을 서술한다. (Render Target)
    * DSV 서술자는 깊이.스텐실 자원을 서술한다. (Depth Stencil)
  ####
  * 서술자 힙은 서술자들의 배열이며, 응용 프로그램이 사용하는 서술자들이 저장되는 곳이다. 
  ####
  * 서술자 종류별로 개별적인 서술자 힙이 필요하다. 같은 종류의 서술자들은 같은 서술자 힙에 저장된다. 한 종류의 서술자에 대해 여러 개의 힙을 둘 수도 있다.
  ####
  * 하나의 자원을 참조하는 서술자가 여러 개일 수 있다. 예를 들어 한 자원의 여러 부분 영역을 여러 서술자가 참조할 수 있다. 또한, 하나의 자원을 렌더링 파이프라인의 여러 단계에 묶을 때 단계마다 개별적인 서술자가 필요하다. 
  ####
  * 서술자들은 응용 프로그램의 초기화 시점에서 생성해야 한다. 그 때 일정 정도의 형식 점검과 유효성 검증이 일어나기 때문이다. 또한 초기화 시점에서 생성하는 것이 실제 실행 시점에서 생성하는 것보다 낫기 때문이기도 하다.

* #### 다중표본화의 이론
  * 안티앨리어싱 기법 중 하나로 초과표본화를 사용할 수 있다.
  * 후면 버퍼와 깊이 버퍼를 화면 해상도보다 4배 (가로 세로 두 배씩) 로 잡고, 3차원 장면을 4배 크기의 해상도에서 후면 버퍼에 렌더링한다. 이미지를 화면 버퍼에 제시할 때가 되면 후면 버퍼를 원래 크기의 버퍼로 환원한다. 이 환원 공정을 하향표본화라고도 부르는데, 4픽셀 블록의 네 색상의 평균을 그 픽셀의 최종 색상으로 사용한다. 화면 해상도를 소프트웨어에서 증가시키는 것이라 할 수 있다.
  * 초과 표본화는 픽셀 처리량과 메모리 소비량이 네 배이므로 비용이 높다. 
  ####
  * Direct3D는 다중표본화라는 절충적인 앨리어싱 제거 기법을 지원한다. 다중표본화는 일부 계산 결과를 공유하여 비용이 초과표본화보다 낮다.
  * 다중표본화도 크기가 해상도의 4배인 후면 버퍼와 깊이 버퍼를 사용한다. 하지만 다중표본화는 이미지 색상을 각 부분픽셀마다 계산하지 않고, 픽셀당 한 번만 (픽셀의 중심) 계산하며, 그 색상과 부분픽셀들의 가시성과 포괄도를 이용해서 최종 색상을 결정한다.

* #### Direct3D의 다중표본화
    * DXGI_SAMPLE_DESC라는 구조체를 채워 다중표본화가 가능하다.
    이 구조체는 다음과 같이 두 개의 멤버로 이루어져 있다.
    ```C++
        typedef struct DXGI_SAMPLE_DESC
        {
            UINT Count;
            UINT Quality;
        } DXGI_SAMPLE_DESC;
    ```
    * Count 멤버는 픽셀당 추춘할 표본의 개수를 지정한다.
    Quality 멤버는 원하는 품질 수준을 지정한다.
    *  텍스처 형식과 표본 개수 조합에 대한 품질 수준들의 개수를 메서드를 통해 알아낼 수 있다.
    *  다중표본화를 사용하지 않을 경우 표본 개수를 1로, 품질 수준을 0으로 설정하면 된다.
* #### DXGI
  * DXGI (DirectX Graphics INfrastructure)는 Direct3D와 함께 쓰이는 API이다. DXGI에 깔린 기본 착안은, 여러 그래픽 API들에 공통인 그래픽 관련 작업들이 존재한다는 것이다. 즉 DXGI는 공통적인 그래픽 기능성을 처리한다. 이를테면 전체 화면 모드 전환 등등.
  ####
  * DXGI의 핵심 인터페이스 중 하나는 IDXGIFactory 인터페이스다.
  이 인터페이스는 주로 IDXGISwapChain 인터페이스 생성과 디스플레이 어댑터 열거에 사용된다. 
  * 디스플레이 어댑터는 그래픽 기능성을 구현하고, 일반적으로 하드웨어 장치(이를테면 그래픽카드)를 말한다. 하드웨어 그래픽 기능성을 흉내내는 소프트웨어 디스플레이 어댑터도 존재한다.
  ####
  * 디스플레이 출력(ex.모니터)은 IDXGIOutput 인터페이스가 대표한다.
  * 디스플레이 모드를 담은 목록을 얻을 수도 있다. 

* #### 상주성
  * 상주성은 간단히 자원이 GPU 메모리에 들어 있는지의 여부를 뜻한다.
  * Direct3D 12에서 응용 프로그램은 자원을 GPU 메모리로부터 내림으로써 ('퇴거'), 그리고 필요하면 다시 GPU에 올림으로써 ('입주') 자원의 상주성을 관리한다.
  * 상주성 관리의 핵심은 응용 프로그램이 사용하는 GPU 메모리의 양을 최소화하는 것이다.
  * 기본적으로 자원을 생성하면 자원이 GPU 메모리에 입주하고, 파괴되면 메모리에서 나간다. 하지만 특정 메소드를 이용해서 응용 프로그램이 상주성을 직접 제어할 수도 있다. 
